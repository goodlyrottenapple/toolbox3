infixl 1 &&
infix 2 âŠ¢ , âˆˆ , âˆ‰, â‰¡, â©¸, â©µ
infixr 3 â†’ , -< , >, âˆ·, $
infix 3 \\ , \
infixl 4 âˆ§, âˆ¨, ;, âˆª, âˆ©

prop (â‰¡) : {a : Type} -> (x : a) -> (y : a) -> Prop where 
  ('= x y)
end

prop (âˆª) : {a : Type} -> (X : Set a) -> (Y : Set a) -> Set a where 
  ('union X Y)
end

prop (\\) : {a : Type} -> (X : Set a) -> (x : a) -> Set a where 
  ('setminus X ('singleton x))
end

prop (âˆˆ) : {a : Type} -> (x : a) -> (X : Set a) -> Prop where
  ('member x X)
end

prop (âˆ‰) : {a : Type} -> (x : a) -> (X : Set a) -> Prop where
  ('not ('member x X))
end

prop singleton : {a : Type} -> (x : a) -> Set a where 
  ('singleton x)
end

prop (&&) : (X : Prop) -> (Y : Prop) -> Prop where 
  ('and X Y)
end

prop infer : {a : Type} -> (x : a) -> Prop where 
  ('= x x)
end

data List : Set Name -> (Ï„ : Set Name -> *) -> * where
    âˆ… : -- {ğ“ : Set Name} -> [ğ“ â‰¡ {| |}] -> -- this is a bit of a hack to force the SMT solver to come up with X automatically
        {Ï„ : Set Name -> *} -> List {| |} Ï„
  | (âˆ·) : {X : Set Name} -> {Y : Set Name} -> {Z : Set Name} -> {Ï„ : Set Name -> *} -> 
        (x : Ï„ X) -> List Y Ï„ -> [Z â‰¡ X âˆª Y] -> List Z Ï„
end


data Trm : Set Name -> * where 
    var : {ğ“ : Set Name} -> (n : Name) -> [ğ“ â‰¡ singleton n] -> Trm ğ“
  | const : Name -> Trm {| |}
  | fun : {ğ“ : Set Name} -> Name -> List ğ“ Trm -> Trm ğ“
end


def empty : List {| 'x |} Trm where
  empty = (var 'x) âˆ· âˆ…
end



data F : Set Name -> * where
    R : Name -> {ğ“ : Set Name} -> List ğ“ Trm -> F ğ“
end




def testF : F {| 'x |} where
  testF = R '+ (var 'x âˆ· âˆ…) 
end
